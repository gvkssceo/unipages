

 Document: Converting a React Web Application
into a Progressive Web App (PWA)
1. What is a PWA?
A Progressive Web App (PWA) is a web application that behaves like a native app:
It can be installed on desktop or mobile (like an app store app).
It works offline (to the extent you configure).
It can use advanced features like push notifications, background sync, and caching strategies.
Why important?
Faster re-loads → cached assets.
App-like user experience.
Better engagement → users can “Add to Home Screen.”
Can send notifications (with setup).
2. Minimum Requirements for a PWA
To pass Lighthouse PWA checks and be installable, you need:
HTTPS hosting (except localhost).
A Web App Manifest (``************************) describing the app.
A Service Worker (``************************) controlling caching/offline.
A small snippet in your React entry point to register the service worker.
3. How Difficult is It?
Easy level: Make it installable (manifest + simple SW).
Medium level: Add offline app shell caching and update handling.
Advanced level: Add push notifications, background sync, API caching.
For your developer: focus first on the Easy + Medium level.
• 
• 
• 
• 
• 
• 
• 
1. 
2. 
3. 
4. 
• 
• 
• 
1

4. Project Setup Notes
Your developer is working on a React project. Depending on build tool:
Create React App (CRA): comes with service worker support (Workbox).
Vite: install vite-plugin-pwa for auto setup.
Next.js: install next-pwa.
If you’re not sure, assume a plain React + Vite build (most modern projects use this).
5. Step-by-Step Implementation
Step 1: Create a manifest.json
In public/manifest.json:
{
"name":"Your App Name",
"short_name":"YourApp",
"start_url":"/?source=pwa",
"display":"standalone",
"background_color":"#ffffff",
"theme_color":"#0ea5e9",
"orientation":"portrait",
"icons": [
{
"src":"/icons/icon-192.png",
"sizes":"192x192",
"type":"image/png"
},
{
"src":"/icons/icon-512.png",
"sizes":"512x512",
"type":"image/png"
}
]
}
 Place manifest.json in the public folder.\  Add icons (icon-192.png, icon-512.png) in /
public/icons/.
• 
• 
• 
2

Step 2: Reference Manifest in index.html
In public/index.html, inside <head>:
<linkrel="manifest"href="/manifest.json"/>
<metaname="theme-color"content="#0ea5e9"/>
Step 3: Create a Service Worker
Add public/sw.js:
constCACHE_NAME='app-shell-v1';
constAPP_SHELL= ['/','/index.html'];// Update with your build output
// Install phase: cache app shell
self.addEventListener('install', (event) => {
event.waitUntil(
caches.open(CACHE_NAME).then((cache) => cache.addAll(APP_SHELL))
);
self.skipWaiting();
});
// Activate phase: remove old caches
self.addEventListener('activate', (event) => {
event.waitUntil(
caches.keys().then((keys) =>
Promise.all(keys.filter((k) => k !==CACHE_NAME).map((k) =>
caches.delete(k)))
)
);
self.clients.claim();
});
// Fetch phase: serve cached, fallback to network
self.addEventListener('fetch', (event) => {
constreq= event.request;
if(req.method!=="GET")return;
// Network-first for HTML
if(req.headers.get("accept")?.includes("text/html")) {
event.respondWith(
fetch(req).then((res) => {
constcopy= res.clone();
caches.open(CACHE_NAME).then((cache) => cache.put('/', copy));
3

returnres;
}).catch(()=> caches.match('/') || caches.match('/index.html'))
);
return;
}
// Cache-first for static assets
event.respondWith(
caches.match(req).then((cached) =>
cached|| fetch(req).then((res) => {
constcopy= res.clone();
caches.open(CACHE_NAME).then((cache) => cache.put(req, copy));
returnres;
})
)
);
});
Step 4: Register the Service Worker
In your src/index.js or src/main.jsx:
if('serviceWorker'innavigator) {
window.addEventListener('load', () => {
navigator.serviceWorker
.register('/sw.js')
.then((reg) => console.log("SW registered:", reg))
.catch((err) => console.error("SW registration failed:", err));
});
}
Step 5: Build and Test
Run npm run build.
Serve with npx serve -s build (or any static server).
Open http://localhost:5000 → you should see “Install App” option in Chrome.
Test offline → you’ll still see the cached shell.
6. Common Gotchas
Routing: For React Router SPAs, ensure index.html is cached as fallback.
1. 
2. 
3. 
4. 
• 
4

Updates: A new deploy won’t auto-refresh unless you add an update prompt logic
(registration.waiting.postMessage({ type: 'SKIP_WAITING' })).
iOS Safari: PWAs work, but no auto-prompt. Users must “Add to Home Screen.” Push works only in
installed web apps (iOS 16.4+).
API Caching: Be careful not to cache sensitive data. Use network-first strategy for APIs.
Storage limits: Browsers allow \~50–100MB before eviction.
7. Extra Features (Advanced, optional later)
Push Notifications: Needs a backend (Firebase Cloud Messaging or Web Push server).
Background Sync: Retry failed network requests when online again.
Advanced Caching: Image caching, API caching, versioned strategies via Workbox.
8. Checklist for Developer
✅ Add manifest.json\ ✅ Add icons\ ✅ Add sw.js with caching strategy\ ✅ Register service worker
in React entry\ ✅ Test with Lighthouse in Chrome DevTools → Fix warnings
9. Learning Resources
Google Developers PWA Checklist
Workbox Docs (advanced service workers)
vite-plugin-pwa (if using Vite)
next-pwa (if using Next.js)
✅ Once your developer follows the above, your React app will be a fully installable PWA   with offline shell.\
Later, you can extend it with push notifications, background sync, or smarter caching.
10. Ready‑Made File Templates (Copy/Paste)
A) /public/manifest.json
{
"name":"UniPages Admin",
"short_name":"UniPages",
"start_url":"/?source=pwa",
"scope":"/",
"display":"standalone",
"background_color":"#ffffff",
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
5

"theme_color":"#0ea5e9",
"orientation":"portrait",
"icons": [
{ "src":"/icons/icon-192.png", "sizes":"192x192", "type":"image/png"},
{ "src":"/icons/icon-512.png", "sizes":"512x512", "type":"image/png"},
{ "src":"/icons/maskable-192.png", "sizes":"192x192", "type":"image/
png", "purpose":"maskable"},
{ "src":"/icons/maskable-512.png", "sizes":"512x512", "type":"image/
png", "purpose":"maskable"}
]
}
B) /public/sw.js (Service Worker – starter)
/* Simple app-shell cache + static assets. Adjust CACHE_NAME each release. */
constCACHE_NAME='unipages-shell-v1';
constAPP_SHELL= ['/','/index.html'];
self.addEventListener('install', (event) => {
event.waitUntil(
caches.open(CACHE_NAME).then((cache) => cache.addAll(APP_SHELL))
);
self.skipWaiting();
});
self.addEventListener('activate', (event) => {
event.waitUntil(
caches.keys().then((keys) =>
Promise.all(keys.filter((k) => k !==CACHE_NAME).map((k) =>
caches.delete(k)))
)
);
self.clients.claim();
});
self.addEventListener('fetch', (event) => {
constreq= event.request;
if(req.method!=='GET')return;
constaccept= req.headers.get('accept') ||'';
constisHTML= accept.includes('text/html');
if(isHTML) {
event.respondWith(
fetch(req)
.then((res) => {
6

constcopy= res.clone();
caches.open(CACHE_NAME).then((c) => c.put('/', copy));
returnres;
})
.catch(()=> caches.match('/') || caches.match('/index.html'))
);
return;
}
event.respondWith(
caches.match(req).then((hit) =>
hit|| fetch(req).then((res) => {
constcopy= res.clone();
caches.open(CACHE_NAME).then((c) => c.put(req, copy));
returnres;
})
)
);
});
self.addEventListener('message', (event) => {
if(event.data&& event.data.type==='SKIP_WAITING') {
self.skipWaiting();
}
});
C) Register SW in React entry (e.g., src/index.js or src/main.jsx)
if('serviceWorker'innavigator) {
window.addEventListener('load', () => {
navigator.serviceWorker
.register('/sw.js')
.then((reg) => {
console.log('SW registered', reg);
if(reg.waiting) {
reg.waiting.postMessage({ type:'SKIP_WAITING'});
}
reg.addEventListener('updatefound', () => {
constnewWorker= reg.installing;
if(!newWorker)return;
newWorker.addEventListener('statechange', () => {
if(newWorker.state==='installed'&&
navigator.serviceWorker.controller) {
console.log('New content available');
}
});
7

});
})
.catch((err) => console.error('SW registration failed:', err));
});
}
D) HTML head snippet (public/index.html)
<linkrel="manifest"href="/manifest.json"/>
<metaname="theme-color"content="#0ea5e9"/>
E) Vite quick setup (optional)
import{ defineConfig}from'vite';
importreactfrom'@vitejs/plugin-react';
import{ VitePWA}from'vite-plugin-pwa';
exportdefaultdefineConfig({
plugins: [
react(),
VitePWA({
registerType:'autoUpdate',
manifest: {/* manifest contents here */}
})
]
});
F) Next.js quick setup (optional)
constwithPWA= require('next-pwa')({
dest:'public',
disable: process.env.NODE_ENV==='development'
});
module.exports= withPWA({ reactStrictMode:true});
G) Folder Structure Example
project/
├─ public/
│  ├─ index.html
│  ├─ manifest.json
│  ├─ sw.js
8

│  └─ icons/
│     ├─ icon-192.png
│     ├─ icon-512.png
│     ├─ maskable-192.png
│     └─ maskable-512.png
├─ src/
│  ├─ main.jsx
│  └─ App.jsx
└─ package.json
11. Timeline & Staffing Estimates
Assumptions: Project already builds successfully, HTTPS hosting available.
A) Minimal, Installable PWA (Easy)
Scope:manifest.json, icons, basic sw.js, registration, Lighthouse pass.
Time: 0.5 – 1.5 days
People: 1 frontend dev
QA:  2–3 hours (browser + Android/iOS)
B) Testing & Hardening
Cross-browser/device matrix: 0.5 – 1 day
Offline routing edge cases: 0.5 – 1 ay
12. Extra Measures for PWA Design
Beyond coding basics, you should also account for design and UX considerations:
Responsive layouts: Ensure the app works across mobile, tablet, and desktop screens seamlessly.
App‑like feel: Use full‑screen mode (display: standalone in manifest), hide unnecessary
browser UI, and apply a clear splash screen.
Offline UX: Provide helpful offline pages or cached fallback content (e.g., show a message or cached
data instead of a blank screen).
Performance budgets: Optimize bundle size, images, and caching so install size remains small.
Accessibility: PWAs should follow accessibility standards (color contrast, keyboard navigation).
Install prompts: Design clear call‑to‑actions (“Install App” banners, explain how to add to home
screen on iOS).
Update experience: Show a non‑disruptive toast/banner when a new version is available, and guide
users to refresh.
Security: Always serve via HTTPS, validate inputs, and avoid caching sensitive user data.
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
9

Testing matrix: Test not only browsers but also devices, including iOS Safari quirks, Android
Chrome, and desktop browsers.
These design‑side measures make the PWA usable, installable, and trustworthy beyond
just being technically compliant.
• 
10